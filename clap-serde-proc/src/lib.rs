// Copyright (C) 2022 Davide Peressoni
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

use proc_macro::TokenStream;
use quote::{format_ident, quote};
use syn::parse_quote;

/// Enables clap and serde derive on the following struct.
///
/// It will automatically implement also the `ClapSerde` and [`Default`] traits.  
/// Use `#[default(value)]` attribute to change the default value of a field.  
/// Use `#[clap_serde]` attribute on the fields which type is a struct generated by this macro
/// (recursive behaviour).
///
/// This derive macro generates a struct (`ClapSerde::Opt`) with the same fields of the original,
/// but which types are wrapped in [`Option`].  
/// Such structure can be parsed from command line with clap and from any serde Deserializer.
/// It can also be merged to the original struct: only the not-`None` fields will be used to update
/// it. See `ClapSerde::update` and `ClapSerde::merge`.
#[proc_macro_derive(
    ClapSerde,
    attributes(clap, structopt, command, arg, group, serde, default, clap_serde)
)]
pub fn clap_serde(item: TokenStream) -> TokenStream {
    // AST of the struct on which this derive proc macro is applied.
    // It will be modified to generate the corresponding Opt.
    let mut ast: syn::DeriveInput = syn::parse(item).unwrap();

    let mut no_fields = syn::punctuated::Punctuated::new();

    // Get a mutable reference to the fields.
    let fields = match &mut ast.data {
        syn::Data::Struct(data) => match &mut data.fields {
            syn::Fields::Named(fields) => &mut fields.named,
            syn::Fields::Unit => &mut no_fields,
            _ => panic!("clap supports only non-tuple structs"),
        },
        syn::Data::Enum(_) => panic!("ClapSerde currently supports only structs"),
        _ => panic!("clap supports only structs and enums"),
    };

    // Get the name of the struct and generate name for the corresponding Opt
    let name = ast.ident;
    ast.ident = format_ident!("ClapSerdeOptional{}", name);
    let opt_name = &ast.ident;
    let default_doc = format!("Create default {}", name);

    // Get generics for trait implementation
    let (impl_generics, ty_generics, where_clause) = ast.generics.split_for_impl();

    let field_names: Vec<_> = fields.iter().map(|f| f.ident.clone().unwrap()).collect();

    // Fields which implement ClapSerde
    let mut recursive_fields = Vec::new();
    // Fields which do not implement ClapSerde
    let mut not_recursive_fields = Vec::new();

    let default_values: Vec<_> = fields
        .iter_mut()
        .map(|f| {
            let ty = f.ty.clone();

            // Default value for this field
            // If no default value was provided use the default for the type
            let mut def_val = parse_quote!(<#ty as core::default::Default>::default());
            // Is this field recursive? (Does it implement ClapSerde?)
            let mut not_recursive = true;

            f.attrs.retain(|attr| {
                if attr.path.is_ident(&format_ident!("default")) {
                    // Found default value
                    def_val = attr.tokens.clone();
                    false
                } else if attr.path.is_ident(&format_ident!("clap_serde")) {
                    // Found declaration of recursive field
                    not_recursive = false;
                    recursive_fields.push(f.ident.clone());
                    f.ty = parse_quote!(<#ty as clap_serde_derive::ClapSerde>::Opt);
                    false
                } else {
                    // Other attributes must be retained
                    true
                }
            });

            if not_recursive {
                not_recursive_fields.push(f.ident.clone());
            }

            // Wrap field type in option
            let ty = &f.ty; // Use possible updated type
            f.ty = parse_quote!(Option<#ty>);

            def_val
        })
        .collect();

    quote! {
        // the struct with options
        #[doc(hidden)]
        #[derive(clap::Parser, serde::Deserialize, core::default::Default)]
        #ast

        // implement ClapSerde
        impl #impl_generics clap_serde_derive::ClapSerde for #name #ty_generics
            #where_clause
        {
            type Opt = #opt_name;

            fn update(&mut self, mut other: impl core::borrow::BorrowMut<Self::Opt>) {
                let other = other.borrow_mut();
                #(
                    if let core::option::Option::Some(v) = other.#not_recursive_fields.take() {
                        self.#not_recursive_fields = v;
                    }
                )*
                #(
                    if let core::option::Option::Some(mut v) = other.#recursive_fields.take() {
                        self.#recursive_fields.update(&mut v);
                    }
                )*
            }
        }

        // implement Default
        impl #impl_generics core::default::Default for #name #ty_generics #where_clause {
            #[doc = #default_doc]
            fn default() -> Self {
                Self {
                    #(
                        #field_names: #default_values,
                    )*
                }
            }
        }

        // implement From
        impl #impl_generics core::convert::From<<Self as clap_serde_derive::ClapSerde>::Opt>
            for #name #ty_generics #where_clause
        {
            /// Create new object from Opt.
            fn from(data: <Self as clap_serde_derive::ClapSerde>::Opt) -> Self {
                Self::default().merge(data)
            }
        }
        impl #impl_generics core::convert::From<&mut <Self as clap_serde_derive::ClapSerde>::Opt>
            for #name #ty_generics #where_clause
        {
            /// Create new object from &mut Opt.
            fn from(data: &mut <Self as clap_serde_derive::ClapSerde>::Opt) -> Self {
                Self::default().merge(data)
            }
        }
    }
    .into()
}
