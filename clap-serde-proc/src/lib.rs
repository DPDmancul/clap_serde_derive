use proc_macro::TokenStream;
use quote::{format_ident, quote};
use syn::parse_quote;

type Fields = syn::punctuated::Punctuated<syn::Field, syn::token::Comma>;

/// Enables clap and serde derive on the following struct.
///
/// It will automatically implement also the ClapSerde and Default traits.  
/// Use `#[default(value)]` attribute to change the default value of a field.  
/// Use `#[clap_serde]` attribute on the fields which type is a struct generated by this macro
/// (recursive behaviour).
#[proc_macro_attribute]
pub fn clap_serde(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let ast: syn::DeriveInput = syn::parse(item).unwrap();

    let mut fields = match ast.data {
        syn::Data::Struct(data) => match data.fields {
            syn::Fields::Named(fields) => fields.named,
            _ => panic!("clap_serde currently supports only named fields structs"),
        },
        _ => panic!("clap_serd currently works only on structs"),
    };

    let attrs = ast.attrs;
    // Remove clap attributes from final struct
    let attrs_without_clap: Vec<_> = attrs
        .iter()
        .filter(|attr| !attr.path.is_ident(&format_ident!("clap")))
        .collect();

    let vis = ast.vis;
    let name = ast.ident;
    // name for private module with struct with Options
    let opt_name = format_ident!("ClapSerdeOptional{}", name);
    let default_doc = format!("Create default {}", name);

    let generics = ast.generics;
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    let field_names: Vec<syn::Ident> = fields.iter().map(|f| f.ident.clone().unwrap()).collect();
    let default_values: Vec<proc_macro2::TokenStream> = fields
        .iter()
        .map(|f| {
            let ty = &f.ty;
            f.attrs
                .iter()
                .find_map(|attr| {
                    attr.path
                        .is_ident(&format_ident!("default"))
                        .then_some(attr.tokens.clone())
                })
                .unwrap_or_else(|| parse_quote!(<#ty as core::default::Default>::default()))
        })
        .collect();

    // remove default args from fields
    fields.iter_mut().for_each(|f| {
        f.attrs
            .retain(|attr| !attr.path.is_ident(&format_ident!("default")))
    });
    // clone fields for struct with Options
    let mut fields_opt: Fields = fields.clone();
    // remove clap and recursive args from fields
    fields.iter_mut().for_each(|f| {
        f.attrs.retain(|attr| {
            !(attr.path.is_ident(&format_ident!("clap"))
                || attr.path.is_ident(&format_ident!("clap_serde")))
        })
    });

    let mut recursive_fields = Vec::new();
    let mut not_recursive_fields = Vec::new();

    // wrap field types in options, excluded recursive ones
    fields_opt.iter_mut().for_each(|f| {
        let mut not_recursive = true;
        f.attrs.retain(|attr| {
            if attr.path.is_ident(&format_ident!("clap_serde")) {
                not_recursive = false;
                recursive_fields.push(f.ident.clone());
                let ty = &f.ty;
                f.ty = parse_quote!(<#ty as clap_serde_derive::ClapSerde>::Opt);
                false
            } else {
                true
            }
        });
        if not_recursive {
            not_recursive_fields.push(f.ident.clone());
        }
        let ty = &f.ty;
        f.ty = parse_quote!(Option<#ty>);
    });

    quote! {
        // the final struct
        #[derive(serde::Serialize)]
        #(#attrs_without_clap)*
        #vis struct #name #generics {
            #fields
        }

        // the struct with options
        #[doc(hidden)]
        #[derive(clap::Parser, serde::Deserialize)]
        #(#attrs)*
        pub struct #opt_name #generics {
            #fields_opt
        }

        impl #impl_generics clap_serde_derive::ClapSerde for #name #ty_generics
            #where_clause
        {
            type Opt = #opt_name;

            fn update(&mut self, mut other: impl core::borrow::BorrowMut<Self::Opt>) {
                let other = other.borrow_mut();
                #(
                    if let core::option::Option::Some(v) = other.#not_recursive_fields.take() {
                        self.#not_recursive_fields = v;
                    }
                )*
                #(
                    if let core::option::Option::Some(mut v) = other.#recursive_fields.take() {
                        self.#recursive_fields.update(&mut v);
                    }
                )*
            }
        }

        impl #impl_generics core::default::Default for #name #ty_generics #where_clause {
            #[doc = #default_doc]
            fn default() -> Self {
                Self {
                    #(
                        #field_names: #default_values,
                    )*
                }
            }
        }

        impl #impl_generics core::convert::From<<Self as clap_serde_derive::ClapSerde>::Opt>
            for #name #ty_generics #where_clause
        {
            /// Create new object from Opt.
            fn from(data: <Self as clap_serde_derive::ClapSerde>::Opt) -> Self {
                Self::default().merge(data)
            }
        }
        impl #impl_generics core::convert::From<&mut <Self as clap_serde_derive::ClapSerde>::Opt>
            for #name #ty_generics #where_clause
        {
            /// Create new object from &mut Opt.
            fn from(data: &mut <Self as clap_serde_derive::ClapSerde>::Opt) -> Self {
                Self::default().merge(data)
            }
        }
    }
    .into()
}
